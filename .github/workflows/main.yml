name: Pull Private Docker Image
'on':
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch: null
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: '${{ secrets.DOCKERHUB_USERNAME }}'
          password: '${{ secrets.DOCKERHUB_TOKEN }}'
      
      - name: Pull Docker image
        run: 'docker pull ${{ secrets.DOCKERHUB_IMAGE_URL }}:latest'
      
      - name: List Docker images
        run: 'docker images ${{ secrets.DOCKERHUB_IMAGE_URL }}'
      
      - name: Install Cloudflared
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/
      
      - name: Start the API container
        run: |
          docker run -d -p 8080:8080 --name api-container ${{ secrets.DOCKERHUB_IMAGE_URL }}:latest
          # Wait for the API to start
          sleep 10
          curl -s http://localhost:8080/
      
      - name: Set up Cloudflare Tunnel
        run: |
          # Create directory for logs
          mkdir -p /tmp/cloudflared
          touch /tmp/cloudflared/tunnel.log
          
          # Start the ephemeral tunnel
          cloudflared tunnel --url http://localhost:8080 --logfile /tmp/cloudflared/tunnel.log --loglevel debug &
          TUNNEL_PID=$!
          
          # Wait for tunnel to initialize
          sleep 10
          
          # Extract and display the tunnel URL
          TUNNEL_URL=$(grep -o 'https://[a-zA-Z0-9.-]*\.trycloudflare\.com' /tmp/cloudflared/tunnel.log | tail -1)
          echo "::notice::Your application is available at: $TUNNEL_URL"
          echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV
          
          # Display logs for debugging
          echo "Cloudflare tunnel logs:"
          tail -n 20 /tmp/cloudflared/tunnel.log
      
      - name: Verify API through tunnel
        run: |
          # Verify the API is accessible through the tunnel
          curl -s ${{ env.TUNNEL_URL }}/health || echo "API status check failed but continuing"
      
      - name: Update repository status in flask_github_manager_final
        if: success() && env.TUNNEL_URL != ''
        run: |
          # Get the repository name from the GitHub repository
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)
          
          # Create JSON payload with updated status and cloudflare tunnel URL
          JSON_PAYLOAD=$(cat << EOF
          {
            "repository_name": "$REPO_NAME",
            "status": "Active",
            "cloudflare_tunnel_url": "${{ env.TUNNEL_URL }}"
          }
          EOF
          )
          
          # Send POST request to update the repository status
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            https://render-measurements-save-officers.trycloudflare.com/api/update_repository_status
          
          echo "::notice::Repository status updated in flask_github_manager_final"
      
      - name: Keep container and tunnel running for monitoring (workflow_dispatch only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Container and tunnel will remain active for 0.5 hour for monitoring. URL: ${{ env.TUNNEL_URL }}"
          sleep 1500
      
      - name: Wait 5 hours before triggering next build
        run: |
          echo "Sleeping for 5 hours before re-dispatching workflow..."
          sleep 18000
  
  trigger_next:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Trigger next chunk
        uses: actions/github-script@v6
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          script: |
            const next = String(parseInt(inputs.part) + 1).padStart(2, '0');
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: context.workflow,
              ref: context.ref.replace('refs/heads/', ''),
              inputs: { part: next }
            });
